
/* Result Sets Interface */
#ifndef SQL_CRSR
#  define SQL_CRSR
  struct sql_cursor
  {
    unsigned int curocn;
    void *ptr1;
    void *ptr2;
    unsigned int magic;
  };
  typedef struct sql_cursor sql_cursor;
  typedef struct sql_cursor SQL_CURSOR;
#endif /* SQL_CRSR */

/* Thread Safety */
typedef void * sql_context;
typedef void * SQL_CONTEXT;

/* Object support */
struct sqltvn
{
  unsigned char *tvnvsn; 
  unsigned short tvnvsnl; 
  unsigned char *tvnnm;
  unsigned short tvnnml; 
  unsigned char *tvnsnm;
  unsigned short tvnsnml;
};
typedef struct sqltvn sqltvn;

struct sqladts
{
  unsigned int adtvsn; 
  unsigned short adtmode; 
  unsigned short adtnum;  
  sqltvn adttvn[1];       
};
typedef struct sqladts sqladts;

static struct sqladts sqladt = {
  1,1,0,
};

/* Binding to PL/SQL Records */
struct sqltdss
{
  unsigned int tdsvsn; 
  unsigned short tdsnum; 
  unsigned char *tdsval[1]; 
};
typedef struct sqltdss sqltdss;
static struct sqltdss sqltds =
{
  1,
  0,
};

/* File name & Package Name */
struct sqlcxp
{
  unsigned short fillen;
           char  filnam[21];
};
static const struct sqlcxp sqlfpn =
{
    20,
    "dbms-output-usage.pc"
};


static unsigned int sqlctx = 72620179;


static struct sqlexd {
   unsigned int   sqlvsn;
   unsigned int   arrsiz;
   unsigned int   iters;
   unsigned int   offset;
   unsigned short selerr;
   unsigned short sqlety;
   unsigned int   occurs;
      const short *cud;
   unsigned char  *sqlest;
      const char  *stmt;
   sqladts *sqladtp;
   sqltdss *sqltdsp;
            void  **sqphsv;
   unsigned int   *sqphsl;
            int   *sqphss;
            void  **sqpind;
            int   *sqpins;
   unsigned int   *sqparm;
   unsigned int   **sqparc;
   unsigned short  *sqpadto;
   unsigned short  *sqptdso;
   unsigned int   sqlcmax;
   unsigned int   sqlcmin;
   unsigned int   sqlcincr;
   unsigned int   sqlctimeout;
   unsigned int   sqlcnowait;
              int   sqfoff;
   unsigned int   sqcmod;
   unsigned int   sqfmod;
   unsigned int   sqlpfmem;
            void  *sqhstv[4];
   unsigned int   sqhstl[4];
            int   sqhsts[4];
            void  *sqindv[4];
            int   sqinds[4];
   unsigned int   sqharm[4];
   unsigned int   *sqharc[4];
   unsigned short  sqadto[4];
   unsigned short  sqtdso[4];
} sqlstm = {13,4};

/* SQLLIB Prototypes */
extern void sqlcxt (void **, unsigned int *,
                    struct sqlexd *, const struct sqlcxp *);
extern void sqlcx2t(void **, unsigned int *,
                    struct sqlexd *, const struct sqlcxp *);
extern void sqlbuft(void **, char *);
extern void sqlgs2t(void **, char *);
extern void sqlorat(void **, unsigned int *, void *);

/* Forms Interface */
static const int IAPSUCC = 0;
static const int IAPFAIL = 1403;
static const int IAPFTL  = 535;
extern void sqliem(unsigned char *, signed int *);

typedef struct { unsigned short len; unsigned char arr[1]; } VARCHAR;
typedef struct { unsigned short len; unsigned char arr[1]; } varchar;

/* cud (compilation unit data) array */
static const short sqlcud0[] =
{13,4130,178,0,0,
5,0,0,1,53,0,6,103,0,0,1,1,0,1,0,1,3,0,0,
24,0,0,2,35,0,6,112,0,0,0,0,0,1,0,
39,0,0,3,71,0,6,139,0,0,2,2,0,1,0,2,97,0,0,2,3,0,0,
62,0,0,4,83,0,6,167,0,0,2,2,0,1,0,2,9,0,0,3,3,0,0,
85,0,0,0,0,0,27,33,0,0,4,4,0,1,0,1,97,0,0,1,10,0,0,1,10,0,0,1,10,0,0,
116,0,0,6,125,0,6,44,0,0,0,0,0,1,0,
131,0,0,7,87,0,6,55,0,0,0,0,0,1,0,
146,0,0,8,110,0,6,65,0,0,0,0,0,1,0,
161,0,0,9,84,0,6,80,0,0,0,0,0,1,0,
176,0,0,10,118,0,6,92,0,0,0,0,0,1,0,
191,0,0,11,0,0,30,108,0,0,0,0,0,1,0,
};


/*
 * dbms-output-usage.pc - Demonstration program for dbms_output_util
 *
 * This example connects using the CONNECT environment variable and
 * showcases the various utility functions defined in dbms_output_util.pc.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// EXEC SQL INCLUDE sqlca;
#include <sqlca.h>

/*
 * Include the DBMS_OUTPUT helper functions directly so the Pro*C
 * precompiler processes them along with this demo program.
 */
/* EXEC SQL INCLUDE dbms_output_util.pc;
 */ 
/*
 * dbms_output_util.pc - Utility functions for handling DBMS_OUTPUT
 *
 * These functions provide flexible ways to retrieve and process
 * DBMS_OUTPUT lines generated by PL/SQL calls.  The implementations
 * are written in C using Pro*C for Oracle database interaction.
 *
 * Functions:
 *   - dbms_output_print_stdout():   Print all DBMS_OUTPUT lines to stdout.
 *   - dbms_output_print_file(FILE*): Print lines to the specified FILE*.
 *   - dbms_output_collect_list():   Gather lines into a linked list.
 *   - dbms_output_collect_buffer(): Gather lines into a single string buffer.
 *   - dbms_output_collect_array():  Store each line in a caller supplied array.
 *
 *  Additional helper utilities are provided for enabling/disabling
 *  DBMS_OUTPUT and for freeing resources allocated by the collect
 *  functions.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>  // for memcpy, strncpy, strdup

#ifdef __CYGWIN__
#include <sqlca.h>
#else
// EXEC SQL INCLUDE SQLCA;
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* Node used for linked list collection */
struct dbms_output_node {
    char *line;
    struct dbms_output_node *next;
};

/* Enable DBMS_OUTPUT with optional buffer size.  Pass 0 for unlimited */
void dbms_output_enable(int bufsize);

/* Disable DBMS_OUTPUT. */
void dbms_output_disable(void);

/* Check sqlca.sqlcode and exit on error */
void dbms_output_check(const char *msg);

/* Generic internal fetch routine used by the public functions */
int dbms_output_fetch(char *line, short *line_ind, int *status);

/* Fetch up to max_lines using DBMS_OUTPUT.GET_LINES */
/* EXEC SQL BEGIN DECLARE SECTION; */ 

#define DBMS_FETCH_MAX_LINE_LENGTH 32767
#define DBMS_FETCH_MAX_LINES 1000  /* or some maximum upper bound */
/* EXEC SQL END DECLARE SECTION; */ 

size_t dbms_output_fetch_lines(char lines[][DBMS_FETCH_MAX_LINE_LENGTH], size_t max_lines);

/* Print all DBMS_OUTPUT lines to stdout */
void dbms_output_print_stdout(void);

/* Print DBMS_OUTPUT lines to specified FILE* (e.g., stderr, log file) */
void dbms_output_print_file(FILE *fp);

/* Collect lines into a linked list.  The head pointer will be set to the
 * start of the list.  The caller is responsible for freeing the list using
 * dbms_output_free_list().
 */
void dbms_output_collect_list(struct dbms_output_node **head);

/* Free a list previously returned by dbms_output_collect_list */
void dbms_output_free_list(struct dbms_output_node *head);

/* Collect all lines into a single buffer.  The buffer must be allocated by
 * the caller and buffer_size specifies its length.  Lines are concatenated
 * with a trailing newline.  The resulting string is always null terminated.
 */
void dbms_output_collect_buffer(char *buffer, size_t buffer_size);

/* Collect lines into an array of strings.  The caller supplies an array of
 * char pointers and the number of elements.  Each entry is allocated using
 * malloc and must be freed by the caller.  The function returns the number
 * of lines stored.  If the array is too small, excess lines are discarded.
 */
size_t dbms_output_collect_array(char **lines, size_t max_lines);

#ifdef __cplusplus
}
#endif

/* Implementation section --------------------------------------------------*/

void dbms_output_enable(int bufsize) {
    /* EXEC SQL WHENEVER SQLERROR DO dbms_output_check("dbms_output.enable"); */ 

    /* EXEC SQL BEGIN DECLARE SECTION; */ 

    int size = bufsize;
    short size_ind = 0;
    /* EXEC SQL END DECLARE SECTION; */ 


    if (bufsize <= 0)
        size_ind = -1; /* NULL --> unlimited */

    /* EXEC SQL EXECUTE
        BEGIN
            dbms_output.enable(:size:size_ind);
        END;
    END-EXEC; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 1;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.stmt = "begin dbms_output . enable ( :size:size_ind ) ; END ;";
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )5;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlstm.sqhstv[0] = (         void  *)&size;
    sqlstm.sqhstl[0] = (unsigned int  )sizeof(int);
    sqlstm.sqhsts[0] = (         int  )0;
    sqlstm.sqindv[0] = (         void  *)&size_ind;
    sqlstm.sqinds[0] = (         int  )0;
    sqlstm.sqharm[0] = (unsigned int  )0;
    sqlstm.sqadto[0] = (unsigned short )0;
    sqlstm.sqtdso[0] = (unsigned short )0;
    sqlstm.sqphsv = sqlstm.sqhstv;
    sqlstm.sqphsl = sqlstm.sqhstl;
    sqlstm.sqphss = sqlstm.sqhsts;
    sqlstm.sqpind = sqlstm.sqindv;
    sqlstm.sqpins = sqlstm.sqinds;
    sqlstm.sqparm = sqlstm.sqharm;
    sqlstm.sqparc = sqlstm.sqharc;
    sqlstm.sqpadto = sqlstm.sqadto;
    sqlstm.sqptdso = sqlstm.sqtdso;
    sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
    if (sqlca.sqlcode < 0) dbms_output_check("dbms_output.enable");
}


}

void dbms_output_disable(void) {
    /* EXEC SQL WHENEVER SQLERROR DO dbms_output_check("dbms_output.disable"); */ 

    /* EXEC SQL EXECUTE
        BEGIN
            dbms_output.disable;
        END;
    END-EXEC; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 1;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.stmt = "begin dbms_output . disable ; END ;";
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )24;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
    if (sqlca.sqlcode < 0) dbms_output_check("dbms_output.disable");
}


}

void dbms_output_check(const char *msg) {
    if (sqlca.sqlcode != 0) {
        fprintf(stderr, "%s failed: ORA-%d: %.*s\n", msg,
                sqlca.sqlcode,
                sqlca.sqlerrm.sqlerrml,
                sqlca.sqlerrm.sqlerrmc);
        exit(EXIT_FAILURE);
    }
}

int dbms_output_fetch(char *line, short *line_ind, int *status) {
    // Variables passed to the SQL block must be declared in the
    // DECLARE SECTION to ensure they are properly handled by Pro*C.
    /* EXEC SQL BEGIN DECLARE SECTION; */ 

    char *x_line = line;
    short *x_line_ind = line_ind;
    int *x_status = status;
    /* EXEC SQL END DECLARE SECTION; */ 


    /* EXEC SQL WHENEVER SQLERROR DO dbms_output_check("dbms_output.get_line"); */ 

    /* EXEC SQL EXECUTE
        BEGIN
            dbms_output.get_line(:x_line:x_line_ind, :x_status);
        END;
    END-EXEC; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 2;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.stmt = "begin dbms_output . get_line ( :x_line:x_line_ind , :x_st\
atus ) ; END ;";
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )39;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlstm.sqhstv[0] = (         void  *)x_line;
    sqlstm.sqhstl[0] = (unsigned int  )0;
    sqlstm.sqhsts[0] = (         int  )0;
    sqlstm.sqindv[0] = (         void  *)x_line_ind;
    sqlstm.sqinds[0] = (         int  )0;
    sqlstm.sqharm[0] = (unsigned int  )0;
    sqlstm.sqadto[0] = (unsigned short )0;
    sqlstm.sqtdso[0] = (unsigned short )0;
    sqlstm.sqhstv[1] = (         void  *)x_status;
    sqlstm.sqhstl[1] = (unsigned int  )sizeof(int);
    sqlstm.sqhsts[1] = (         int  )0;
    sqlstm.sqindv[1] = (         void  *)0;
    sqlstm.sqinds[1] = (         int  )0;
    sqlstm.sqharm[1] = (unsigned int  )0;
    sqlstm.sqadto[1] = (unsigned short )0;
    sqlstm.sqtdso[1] = (unsigned short )0;
    sqlstm.sqphsv = sqlstm.sqhstv;
    sqlstm.sqphsl = sqlstm.sqhstl;
    sqlstm.sqphss = sqlstm.sqhsts;
    sqlstm.sqpind = sqlstm.sqindv;
    sqlstm.sqpins = sqlstm.sqinds;
    sqlstm.sqparm = sqlstm.sqharm;
    sqlstm.sqparc = sqlstm.sqharc;
    sqlstm.sqpadto = sqlstm.sqadto;
    sqlstm.sqptdso = sqlstm.sqtdso;
    sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
    if (sqlca.sqlcode < 0) dbms_output_check("dbms_output.get_line");
}


    return *status;
}


/* EXEC SQL BEGIN DECLARE SECTION; */ 

    static /* VARCHAR ora_lines[DBMS_FETCH_MAX_LINES][DBMS_FETCH_MAX_LINE_LENGTH + 1]; */ 
struct { unsigned short len; unsigned char arr[32770]; } ora_lines[1000];

    static short   ora_lines_ind[DBMS_FETCH_MAX_LINES];
/* EXEC SQL END DECLARE SECTION; */ 


size_t dbms_output_fetch_lines(char lines[][DBMS_FETCH_MAX_LINE_LENGTH], size_t max_lines) {

    size_t fetched = 0;

    while (fetched < max_lines) {
        /* EXEC SQL BEGIN DECLARE SECTION; */ 

        int ora_num_lines = (int) (max_lines - fetched);
        /* EXEC SQL END DECLARE SECTION; */ 


        if (ora_num_lines > DBMS_FETCH_MAX_LINES)
            ora_num_lines = DBMS_FETCH_MAX_LINES;

        memset(ora_lines_ind, 0, sizeof(ora_lines_ind));
        /* EXEC SQL WHENEVER SQLERROR DO dbms_output_check("dbms_output.get_lines"); */ 

        /* EXEC SQL EXECUTE
            BEGIN
                DBMS_OUTPUT.GET_LINES(:ora_lines:ora_lines_ind, :ora_num_lines);
            END;
        END-EXEC; */ 

{
        struct sqlexd sqlstm;
        sqlstm.sqlvsn = 13;
        sqlstm.arrsiz = 2;
        sqlstm.sqladtp = &sqladt;
        sqlstm.sqltdsp = &sqltds;
        sqlstm.stmt = "begin DBMS_OUTPUT . GET_LINES ( :ora_lines:ora_lines_\
ind , :ora_num_lines ) ; END ;";
        sqlstm.iters = (unsigned int  )1;
        sqlstm.offset = (unsigned int  )62;
        sqlstm.cud = sqlcud0;
        sqlstm.sqlest = (unsigned char  *)&sqlca;
        sqlstm.sqlety = (unsigned short)4352;
        sqlstm.occurs = (unsigned int  )0;
        sqlstm.sqhstv[0] = (         void  *)ora_lines;
        sqlstm.sqhstl[0] = (unsigned int  )32770;
        sqlstm.sqhsts[0] = (         int  )32772;
        sqlstm.sqindv[0] = (         void  *)ora_lines_ind;
        sqlstm.sqinds[0] = (         int  )sizeof(short);
        sqlstm.sqharm[0] = (unsigned int  )1000;
        sqlstm.sqharc[0] = (unsigned int   *)0;
        sqlstm.sqadto[0] = (unsigned short )0;
        sqlstm.sqtdso[0] = (unsigned short )0;
        sqlstm.sqhstv[1] = (         void  *)&ora_num_lines;
        sqlstm.sqhstl[1] = (unsigned int  )sizeof(int);
        sqlstm.sqhsts[1] = (         int  )0;
        sqlstm.sqindv[1] = (         void  *)0;
        sqlstm.sqinds[1] = (         int  )0;
        sqlstm.sqharm[1] = (unsigned int  )0;
        sqlstm.sqadto[1] = (unsigned short )0;
        sqlstm.sqtdso[1] = (unsigned short )0;
        sqlstm.sqphsv = sqlstm.sqhstv;
        sqlstm.sqphsl = sqlstm.sqhstl;
        sqlstm.sqphss = sqlstm.sqhsts;
        sqlstm.sqpind = sqlstm.sqindv;
        sqlstm.sqpins = sqlstm.sqinds;
        sqlstm.sqparm = sqlstm.sqharm;
        sqlstm.sqparc = sqlstm.sqharc;
        sqlstm.sqpadto = sqlstm.sqadto;
        sqlstm.sqptdso = sqlstm.sqtdso;
        sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
        if (sqlca.sqlcode < 0) dbms_output_check("dbms_output.get_lines");
}



        if (sqlca.sqlcode == 1403) {  // No more lines
                break;  // Exit loop if no more lines to fetch
        }
        dbms_output_check("dbms_output.get_lines");

        if (ora_num_lines <= 0) {
            break;  // No lines fetched, exit loop
        }

        for (int i = 0; i < ora_num_lines; ++i) {
            if (ora_lines_ind[i] < 0 || ora_lines[i].len <= 0)
                continue;
            strncpy(lines[fetched], (const char *)ora_lines[i].arr,
                    ora_lines[i].len);
            lines[fetched][ora_lines[i].len] = '\0';  // null-terminate
            fetched++;
        }
    }

    return fetched;
}

void dbms_output_print_stdout(void) {
    char lines[20][32767];
    size_t found;

    do {
        found = dbms_output_fetch_lines(lines, 20);
        for (size_t i = 0; i < found; ++i)
            printf("%s\n", lines[i]);
    } while (found > 0);
}

void dbms_output_print_file(FILE *fp) {
    if (!fp)
        return;

    char lines[20][DBMS_FETCH_MAX_LINE_LENGTH];
    size_t count;

    do {
        count = dbms_output_fetch_lines(lines, 20);
        for (size_t i = 0; i < count; ++i)
            fprintf(fp, "%s\n", lines[i]);
    } while (count > 0);
}

void dbms_output_collect_list(struct dbms_output_node **head) {
    if (!head)
        return;

    *head = NULL;
    struct dbms_output_node **current = head;

    char lines[20][DBMS_FETCH_MAX_LINE_LENGTH];
    size_t count;

    do {
        count = dbms_output_fetch_lines(lines, 20);
        for (size_t i = 0; i < count; ++i) {
            struct dbms_output_node *node =
                (struct dbms_output_node *) malloc(sizeof(struct dbms_output_node));
            if (!node)
                return;
            node->line = strdup(lines[i]);
            node->next = NULL;
            *current = node;
            current = &node->next;
        }
    } while (count > 0);
}

void dbms_output_free_list(struct dbms_output_node *head)
{
    while (head)
    {
        struct dbms_output_node *tmp = head->next;
        free(head->line);
        free(head);
        head = tmp;
    }
}

void dbms_output_collect_buffer(char *buffer, size_t buffer_size)
{
    if (!buffer || buffer_size == 0)
        return;

    buffer[0] = '\0';
    size_t pos = 0;
    char lines[20][32767];
    size_t count;

    do {
        count = dbms_output_fetch_lines(lines, 20);
        for (size_t i = 0; i < count; ++i) {
            size_t len = strlen(lines[i]);
            if (pos + len + 2 >= buffer_size) {
                buffer[pos] = '\0';
                return;
            }
            memcpy(buffer + pos, lines[i], len);
            pos += len;
            buffer[pos++] = '\n';
            buffer[pos] = '\0';
        }
    } while (count > 0);
}

size_t dbms_output_collect_array(char **lines, size_t max_lines)
{
    if (!lines || max_lines == 0)
        return 0;

    size_t count = 0;
    char chunk[20][32767];
    size_t fetched;

    do {
        fetched = dbms_output_fetch_lines(chunk, 20);
        for (size_t i = 0; i < fetched && count < max_lines; ++i)
            lines[count++] = strdup(chunk[i]);
    } while (fetched > 0 && count < max_lines);

    /* Drain any remaining lines */
    while (fetched > 0)
        fetched = dbms_output_fetch_lines(chunk, 20);

    return count;
}


/* Simple helper to connect using CONNECT env variable */
static void connect_db(void)
{
    /* EXEC SQL BEGIN DECLARE SECTION; */ 

    const char *connect = getenv("CONNECT");
    /* EXEC SQL END DECLARE SECTION; */ 


    if (!connect) {
        fprintf(stderr, "CONNECT environment variable not set.\n");
        exit(EXIT_FAILURE);
    }

    /* EXEC SQL CONNECT :connect; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 4;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )10;
    sqlstm.offset = (unsigned int  )85;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlstm.sqhstv[0] = (         void  *)connect;
    sqlstm.sqhstl[0] = (unsigned int  )0;
    sqlstm.sqhsts[0] = (         int  )0;
    sqlstm.sqindv[0] = (         void  *)0;
    sqlstm.sqinds[0] = (         int  )0;
    sqlstm.sqharm[0] = (unsigned int  )0;
    sqlstm.sqadto[0] = (unsigned short )0;
    sqlstm.sqtdso[0] = (unsigned short )0;
    sqlstm.sqphsv = sqlstm.sqhstv;
    sqlstm.sqphsl = sqlstm.sqhstl;
    sqlstm.sqphss = sqlstm.sqhsts;
    sqlstm.sqpind = sqlstm.sqindv;
    sqlstm.sqpins = sqlstm.sqinds;
    sqlstm.sqparm = sqlstm.sqharm;
    sqlstm.sqparc = sqlstm.sqharc;
    sqlstm.sqpadto = sqlstm.sqadto;
    sqlstm.sqptdso = sqlstm.sqtdso;
    sqlstm.sqlcmax = (unsigned int )100;
    sqlstm.sqlcmin = (unsigned int )2;
    sqlstm.sqlcincr = (unsigned int )1;
    sqlstm.sqlctimeout = (unsigned int )0;
    sqlstm.sqlcnowait = (unsigned int )0;
    sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
    if (sqlca.sqlcode < 0) dbms_output_check("dbms_output.get_lines");
}


    dbms_output_check("CONNECT");
}

int main(void)
{
    /* Connect and enable DBMS_OUTPUT */
    connect_db();
    dbms_output_enable(0); /* unlimited buffer */

    /* Generate some output via PL/SQL */
    /* EXEC SQL EXECUTE BEGIN
        dbms_output.put_line('Line 1');
        dbms_output.put_line('Line 2');
        dbms_output.put_line('Line 3');
    END; END-EXEC; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 4;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.stmt = "begin dbms_output . put_line ( 'Line 1' ) ; dbms_output .\
 put_line ( 'Line 2' ) ; dbms_output . put_line ( 'Line 3' ) ; END ;";
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )116;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
    if (sqlca.sqlcode < 0) dbms_output_check("dbms_output.get_lines");
}


    dbms_output_check("put_line");

    printf("-- Print to stdout --\n");
    dbms_output_print_stdout();

    /* Generate more output */
    /* EXEC SQL EXECUTE BEGIN
        dbms_output.put_line('Line A');
        dbms_output.put_line('Line B');
    END; END-EXEC; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 4;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.stmt = "begin dbms_output . put_line ( 'Line A' ) ; dbms_output .\
 put_line ( 'Line B' ) ; END ;";
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )131;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
    if (sqlca.sqlcode < 0) dbms_output_check("dbms_output.get_lines");
}


    dbms_output_check("put_line");

    printf("-- Print to stderr via FILE* --\n");
    dbms_output_print_file(stderr);

    /* Generate output for collection examples */
    /* EXEC SQL EXECUTE BEGIN
        dbms_output.put_line('X');
        dbms_output.put_line('Y');
        dbms_output.put_line('Z');
    END; END-EXEC; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 4;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.stmt = "begin dbms_output . put_line ( 'X' ) ; dbms_output . put_\
line ( 'Y' ) ; dbms_output . put_line ( 'Z' ) ; END ;";
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )146;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
    if (sqlca.sqlcode < 0) dbms_output_check("dbms_output.get_lines");
}


    dbms_output_check("put_line");

    printf("-- Collect into linked list --\n");
    struct dbms_output_node *list = NULL;
    dbms_output_collect_list(&list);
    for (struct dbms_output_node *n = list; n; n = n->next)
        printf("%s\n", n->line);
    dbms_output_free_list(list);

    /* Generate again */
    /* EXEC SQL EXECUTE BEGIN
        dbms_output.put_line('Alpha');
        dbms_output.put_line('Beta');
    END; END-EXEC; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 4;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.stmt = "begin dbms_output . put_line ( 'Alpha' ) ; dbms_output . \
put_line ( 'Beta' ) ; END ;";
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )161;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
    if (sqlca.sqlcode < 0) dbms_output_check("dbms_output.get_lines");
}


    dbms_output_check("put_line");

    printf("-- Collect into buffer --\n");
    char buf[1024];
    dbms_output_collect_buffer(buf, sizeof(buf));
    printf("%s", buf);

    /* Generate again */
    /* EXEC SQL EXECUTE BEGIN
        dbms_output.put_line('One');
        dbms_output.put_line('Two');
        dbms_output.put_line('Three');
    END; END-EXEC; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 4;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.stmt = "begin dbms_output . put_line ( 'One' ) ; dbms_output . pu\
t_line ( 'Two' ) ; dbms_output . put_line ( 'Three' ) ; END ;";
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )176;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
    if (sqlca.sqlcode < 0) dbms_output_check("dbms_output.get_lines");
}


    dbms_output_check("put_line");

    printf("-- Collect into array --\n");
    char *lines[5];
    size_t count = dbms_output_collect_array(lines, 5);
    for (size_t i = 0; i < count; ++i) {
        printf("%s\n", lines[i]);
        free(lines[i]);
    }

    dbms_output_disable();
    /* EXEC SQL COMMIT WORK RELEASE; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 4;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )191;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
    if (sqlca.sqlcode < 0) dbms_output_check("dbms_output.get_lines");
}


    return 0;
}

