/*
 * dbms_output_util.pc - Utility functions for handling DBMS_OUTPUT
 *
 * These functions provide flexible ways to retrieve and process
 * DBMS_OUTPUT lines generated by PL/SQL calls.  The implementations
 * are written in C using Pro*C for Oracle database interaction.
 *
 * Functions:
 *   - dbms_output_print_stdout():   Print all DBMS_OUTPUT lines to stdout.
 *   - dbms_output_print_file(FILE*): Print lines to the specified FILE*.
 *   - dbms_output_collect_list():   Gather lines into a linked list.
 *   - dbms_output_collect_buffer(): Gather lines into a single string buffer.
 *   - dbms_output_collect_array():  Store each line in a caller supplied array.
 *
 *  Additional helper utilities are provided for enabling/disabling
 *  DBMS_OUTPUT and for freeing resources allocated by the collect
 *  functions.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>  // for memcpy, strncpy, strdup

#ifdef __CYGWIN__
#include <sqlca.h>
#else
// EXEC SQL INCLUDE SQLCA;
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* Node used for linked list collection */
struct dbms_output_node {
    char *line;
    struct dbms_output_node *next;
};

/* Enable DBMS_OUTPUT with optional buffer size.  Pass 0 for unlimited */
void dbms_output_enable(int bufsize);

/* Disable DBMS_OUTPUT. */
void dbms_output_disable(void);

/* Check sqlca.sqlcode and exit on error */
void dbms_output_check(const char *msg);

/* Generic internal fetch routine used by the public functions */
int dbms_output_fetch(char *line, short *line_ind, int *status);

/* Fetch up to max_lines using DBMS_OUTPUT.GET_LINES */
EXEC SQL BEGIN DECLARE SECTION;
#define DBMS_FETCH_MAX_LINE_LENGTH 32767
#define DBMS_FETCH_MAX_LINES 1000  /* or some maximum upper bound */
EXEC SQL END DECLARE SECTION;
size_t dbms_output_fetch_lines(char lines[][DBMS_FETCH_MAX_LINE_LENGTH], size_t max_lines);

/* Print all DBMS_OUTPUT lines to stdout */
void dbms_output_print_stdout(void);

/* Print DBMS_OUTPUT lines to specified FILE* (e.g., stderr, log file) */
void dbms_output_print_file(FILE *fp);

/* Collect lines into a linked list.  The head pointer will be set to the
 * start of the list.  The caller is responsible for freeing the list using
 * dbms_output_free_list().
 */
void dbms_output_collect_list(struct dbms_output_node **head);

/* Free a list previously returned by dbms_output_collect_list */
void dbms_output_free_list(struct dbms_output_node *head);

/* Collect all lines into a single buffer.  The buffer must be allocated by
 * the caller and buffer_size specifies its length.  Lines are concatenated
 * with a trailing newline.  The resulting string is always null terminated.
 */
void dbms_output_collect_buffer(char *buffer, size_t buffer_size);

/* Collect lines into an array of strings.  The caller supplies an array of
 * char pointers and the number of elements.  Each entry is allocated using
 * malloc and must be freed by the caller.  The function returns the number
 * of lines stored.  If the array is too small, excess lines are discarded.
 */
size_t dbms_output_collect_array(char **lines, size_t max_lines);

#ifdef __cplusplus
}
#endif

/* Implementation section --------------------------------------------------*/

void dbms_output_enable(int bufsize) {
    EXEC SQL WHENEVER SQLERROR DO dbms_output_check("dbms_output.enable");
    EXEC SQL BEGIN DECLARE SECTION;
    int size = bufsize;
    short size_ind = 0;
    EXEC SQL END DECLARE SECTION;

    if (bufsize <= 0)
        size_ind = -1; /* NULL --> unlimited */

    EXEC SQL EXECUTE
        BEGIN
            dbms_output.enable(:size:size_ind);
        END;
    END-EXEC;
}

void dbms_output_disable(void) {
    EXEC SQL WHENEVER SQLERROR DO dbms_output_check("dbms_output.disable");
    EXEC SQL EXECUTE
        BEGIN
            dbms_output.disable;
        END;
    END-EXEC;
}

void dbms_output_check(const char *msg) {
    if (sqlca.sqlcode != 0) {
        fprintf(stderr, "%s failed: ORA-%d: %.*s\n", msg,
                sqlca.sqlcode,
                sqlca.sqlerrm.sqlerrml,
                sqlca.sqlerrm.sqlerrmc);
        exit(EXIT_FAILURE);
    }
}

int dbms_output_fetch(char *line, short *line_ind, int *status) {
    // Variables passed to the SQL block must be declared in the
    // DECLARE SECTION to ensure they are properly handled by Pro*C.
    EXEC SQL BEGIN DECLARE SECTION;
    char *x_line = line;
    short *x_line_ind = line_ind;
    int *x_status = status;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL WHENEVER SQLERROR DO dbms_output_check("dbms_output.get_line");
    EXEC SQL EXECUTE
        BEGIN
            dbms_output.get_line(:x_line:x_line_ind, :x_status);
        END;
    END-EXEC;
    return *status;
}


EXEC SQL BEGIN DECLARE SECTION;
    static VARCHAR ora_lines[DBMS_FETCH_MAX_LINES][DBMS_FETCH_MAX_LINE_LENGTH + 1];
    static short   ora_lines_ind[DBMS_FETCH_MAX_LINES];
EXEC SQL END DECLARE SECTION;

size_t dbms_output_fetch_lines(char lines[][DBMS_FETCH_MAX_LINE_LENGTH], size_t max_lines) {

    size_t fetched = 0;

    while (fetched < max_lines) {
        EXEC SQL BEGIN DECLARE SECTION;
        int ora_num_lines = (int) (max_lines - fetched);
        EXEC SQL END DECLARE SECTION;

        if (ora_num_lines > DBMS_FETCH_MAX_LINES)
            ora_num_lines = DBMS_FETCH_MAX_LINES;

        memset(ora_lines_ind, 0, sizeof(ora_lines_ind));
        EXEC SQL WHENEVER SQLERROR DO dbms_output_check("dbms_output.get_lines");
        EXEC SQL EXECUTE
            BEGIN
                DBMS_OUTPUT.GET_LINES(:ora_lines:ora_lines_ind, :ora_num_lines);
            END;
        END-EXEC;

        if (sqlca.sqlcode == 1403) {  // No more lines
                break;  // Exit loop if no more lines to fetch
        }
        dbms_output_check("dbms_output.get_lines");

        if (ora_num_lines <= 0) {
            break;  // No lines fetched, exit loop
        }

        for (int i = 0; i < ora_num_lines; ++i) {
            if (ora_lines_ind[i] < 0 || ora_lines[i].len <= 0)
                continue;
            strncpy(lines[fetched], (const char *)ora_lines[i].arr,
                    ora_lines[i].len);
            lines[fetched][ora_lines[i].len] = '\0';  // null-terminate
            fetched++;
        }
    }

    return fetched;
}

void dbms_output_print_stdout(void) {
    char lines[20][32767];
    size_t found;

    do {
        found = dbms_output_fetch_lines(lines, 20);
        for (size_t i = 0; i < found; ++i)
            printf("%s\n", lines[i]);
    } while (found > 0);
}

void dbms_output_print_file(FILE *fp) {
    if (!fp)
        return;

    char lines[20][DBMS_FETCH_MAX_LINE_LENGTH];
    size_t count;

    do {
        count = dbms_output_fetch_lines(lines, 20);
        for (size_t i = 0; i < count; ++i)
            fprintf(fp, "%s\n", lines[i]);
    } while (count > 0);
}

void dbms_output_collect_list(struct dbms_output_node **head) {
    if (!head)
        return;

    *head = NULL;
    struct dbms_output_node **current = head;

    char lines[20][DBMS_FETCH_MAX_LINE_LENGTH];
    size_t count;

    do {
        count = dbms_output_fetch_lines(lines, 20);
        for (size_t i = 0; i < count; ++i) {
            struct dbms_output_node *node =
                (struct dbms_output_node *) malloc(sizeof(struct dbms_output_node));
            if (!node)
                return;
            node->line = strdup(lines[i]);
            node->next = NULL;
            *current = node;
            current = &node->next;
        }
    } while (count > 0);
}

void dbms_output_free_list(struct dbms_output_node *head)
{
    while (head)
    {
        struct dbms_output_node *tmp = head->next;
        free(head->line);
        free(head);
        head = tmp;
    }
}

void dbms_output_collect_buffer(char *buffer, size_t buffer_size)
{
    if (!buffer || buffer_size == 0)
        return;

    buffer[0] = '\0';
    size_t pos = 0;
    char lines[20][32767];
    size_t count;

    do {
        count = dbms_output_fetch_lines(lines, 20);
        for (size_t i = 0; i < count; ++i) {
            size_t len = strlen(lines[i]);
            if (pos + len + 2 >= buffer_size) {
                buffer[pos] = '\0';
                return;
            }
            memcpy(buffer + pos, lines[i], len);
            pos += len;
            buffer[pos++] = '\n';
            buffer[pos] = '\0';
        }
    } while (count > 0);
}

size_t dbms_output_collect_array(char **lines, size_t max_lines)
{
    if (!lines || max_lines == 0)
        return 0;

    size_t count = 0;
    char chunk[20][32767];
    size_t fetched;

    do {
        fetched = dbms_output_fetch_lines(chunk, 20);
        for (size_t i = 0; i < fetched && count < max_lines; ++i)
            lines[count++] = strdup(chunk[i]);
    } while (fetched > 0 && count < max_lines);

    /* Drain any remaining lines */
    while (fetched > 0)
        fetched = dbms_output_fetch_lines(chunk, 20);

    return count;
}
